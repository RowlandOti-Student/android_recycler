<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ItemSwipeHelper.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=0;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">debugAndroidTest</a> &gt; <a href="index.source.html" class="el_package">universum.studios.android.recycler.helper</a> &gt; <span class="el_source">ItemSwipeHelper.java</span></div><h1>ItemSwipeHelper.java</h1><pre class="source lang-java linenums">/*
 * =================================================================================================
 *                             Copyright (C) 2017 Universum Studios
 * =================================================================================================
 *         Licensed under the Apache License, Version 2.0 or later (further &quot;License&quot; only).
 * -------------------------------------------------------------------------------------------------
 * You may use this file only in compliance with the License. More details and copy of this License 
 * you may obtain at
 * 
 * 		http://www.apache.org/licenses/LICENSE-2.0
 * 
 * You can redistribute, modify or publish any part of the code written within this file but as it 
 * is described in the License, the software distributed under the License is distributed on an 
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES or CONDITIONS OF ANY KIND.
 * 
 * See the License for the specific language governing permissions and limitations under the License.
 * =================================================================================================
 */
package universum.studios.android.recycler.helper;

import android.support.annotation.FloatRange;
import android.support.annotation.IntRange;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.VisibleForTesting;
import android.support.v4.view.animation.FastOutSlowInInterpolator;
import android.support.v7.widget.DefaultItemAnimator;
import android.support.v7.widget.RecyclerView;
import android.view.View;
import android.view.ViewPropertyAnimator;
import android.view.animation.Interpolator;

import java.util.ArrayList;
import java.util.List;

/**
 * A {@link RecyclerViewItemHelper} that may be used to support &lt;b&gt;swipe&lt;/b&gt; feature for items
 * displayed in a {@link RecyclerView} widget. Instance of this helper may be simply created via
 * {@link #ItemSwipeHelper()} constructor.
 * &lt;p&gt;
 * In order to support swipe feature for a desired adapter, such adapter must implement {@link SwipeAdapter}
 * interface and needs to be attached to its corresponding {@link RecyclerView} before call to
 * {@link #attachToRecyclerView(RecyclerView)} which will attach such adapter to the swipe helper
 * automatically. Also all {@link RecyclerView.ViewHolder ViewHolders} of that adapter of which item
 * views are desired to be swiped, must implement {@link SwipeViewHolder} interface as other view
 * holder implementations will be ignored by the ItemSwipeHelper API. When the {@link SwipeAdapter}
 * is properly attached, the item helper will delegate to it all swipe gesture related callbacks/events
 * whenever appropriate via the adapter's interface.
 *
 * &lt;h3&gt;Swipe Callbacks&lt;/h3&gt;
 * A {@link OnSwipeListener} may be registered for the helper's {@link ItemSwipeHelper.Interactor}
 * via {@link ItemSwipeHelper.Interactor#addOnSwipeListener(OnSwipeListener)} in order to receive
 * callbacks about &lt;b&gt;started&lt;/b&gt;, &lt;b&gt;finished&lt;/b&gt; or &lt;b&gt;canceled&lt;/b&gt; swipe gesture for a particular
 * {@link RecyclerView.ViewHolder ViewHolder}. If the listener is no more needed it should be
 * unregistered via {@link ItemSwipeHelper.Interactor#removeOnSwipeListener(OnSwipeListener)}.
 *
 * @author Martin Albedinsky
 */
public final class ItemSwipeHelper extends RecyclerViewItemHelper&lt;ItemSwipeHelper.Interactor&gt; {

	/*
	 * Constants ===================================================================================
	 */

	/**
	 * Log TAG.
	 */
	// private static final String TAG = &quot;ItemSwipeHelper&quot;;

	/**
	 * Interaction constant specific for {@link ItemSwipeHelper}.
	 *
	 * @see #ACTION_STATE_SWIPE
	 */
	public static final int INTERACTION = ACTION_STATE_SWIPE;

	/**
	 * Default swipe threshold for the swipe gesture.
	 */
	public static final float SWIPE_THRESHOLD = 0.5f;

	/**
	 * Default duration for animation used to restore position of the holder's item view.
	 *
	 * @see #restoreHolder(RecyclerView.ViewHolder, int, Runnable)
	 */
	public static final long RESTORE_HOLDER_ANIMATION_DURATION = 300;

	/*
	 * Interface ===================================================================================
	 */

	/**
	 * Required interface for adapters which want to support swipe feature for theirs
	 * {@link RecyclerView.ViewHolder ViewHolders}.
	 *
	 * @author Martin Albedinsky
	 */
	public interface SwipeAdapter {

		/**
		 * Called by the swipe helper to obtain swipe movement flags for an item at the specified
		 * &lt;var&gt;position&lt;/var&gt;.
		 *
		 * @param position Position of the item for which to obtain its swipe flags.
		 * @return Movement flags determining in which direction can be the item swiped.
		 * @see ItemSwipeHelper#makeSwipeFlags(int)
		 */
		int getItemSwipeFlags(int position);
	}

	/**
	 * Required interface for all {@link RecyclerView.ViewHolder ViewHolders} which want to support
	 * swipe feature for theirs corresponding item views.
	 *
	 * @author Martin Albedinsky
	 */
	public interface SwipeViewHolder extends InteractiveViewHolder {

		/**
		 * Called by the swipe helper whenever swipe gesture for view of this holder is started.
		 *
		 * @see #onSwipeFinished(int)
		 * @see #onSwipeCanceled()
		 * @see ItemSwipeHelper.Callback#onSelectedChanged(RecyclerView.ViewHolder, int)
		 */
		void onSwipeStarted();

		/**
		 * Called by the swipe helper whenever swipe gesture for view of this holder is finished in
		 * the specified &lt;var&gt;direction&lt;/var&gt;.
		 *
		 * @param direction The direction in which has the swipe gestured finished. One of directions
		 *                  defined by {@link Direction @Direction} annotation.
		 * @see #onSwipeStarted()
		 * @see ItemSwipeHelper.Callback#onSwiped(RecyclerView.ViewHolder, int)
		 */
		void onSwipeFinished(@Direction int direction);

		/**
		 * Called by the swipe helper whenever swipe gesture for view of this holder is canceled.
		 *
		 * @see #onSwipeStarted()
		 * @see ItemSwipeHelper.Callback#clearView(RecyclerView, RecyclerView.ViewHolder)
		 */
		void onSwipeCanceled();
	}

	/**
	 * Listener which may be used to receive callbacks about &lt;b&gt;started&lt;/b&gt;, &lt;b&gt;finished&lt;/b&gt; or
	 * &lt;b&gt;canceled&lt;/b&gt; swipe gesture for a specific {@link RecyclerView.ViewHolder} instance.
	 *
	 * @author Martin Albedinsky
	 */
	public interface OnSwipeListener {

		/**
		 * Invoked whenever swipe gesture is started for the given &lt;var&gt;viewHolder&lt;/var&gt;.
		 *
		 * @param swipeHelper The item helper controlling the swipe gesture for the view holder.
		 * @param viewHolder  The view holder for which has been the swipe gesture started.
		 * @see #onSwipeFinished(ItemSwipeHelper, RecyclerView.ViewHolder, int)
		 */
		void onSwipeStarted(@NonNull ItemSwipeHelper swipeHelper, @NonNull RecyclerView.ViewHolder viewHolder);

		/**
		 * Invoked whenever swipe gesture is finished for the given &lt;var&gt;viewHolder&lt;/var&gt;.
		 *
		 * @param swipeHelper The item helper controlling the swipe gesture for the view holder.
		 * @param viewHolder  The view holder for which has been the swipe gesture finished.
		 * @param direction   The direction in which has been the swipe gesture finished. One of
		 *                    directions defined by {@link Direction @Direction} annotation.
		 * @see #onSwipeStarted(ItemSwipeHelper, RecyclerView.ViewHolder)
		 */
		void onSwipeFinished(@NonNull ItemSwipeHelper swipeHelper, @NonNull RecyclerView.ViewHolder viewHolder, @Direction int direction);

		/**
		 * Invoked whenever swipe gesture is canceled for the given &lt;var&gt;viewHolder&lt;/var&gt;.
		 *
		 * @param swipeHelper The item helper controlling the swipe gesture for the view holder.
		 * @param viewHolder  The view holder for which has been the swipe gesture canceled.
		 */
		void onSwipeCanceled(@NonNull ItemSwipeHelper swipeHelper, @NonNull RecyclerView.ViewHolder viewHolder);
	}

	/*
	 * Static members ==============================================================================
	 */

	/*
	 * Members =====================================================================================
	 */

	/**
	 * Duration of animation used to restore position of holder's item view to its initial state.
	 */
<span class="fc" id="L197">	private long mRestoreHolderAnimationDuration = RESTORE_HOLDER_ANIMATION_DURATION;</span>

	/**
	 * Interpolator for animation used to restore position of holder's item view.
	 */
<span class="fc" id="L202">	private Interpolator mRestoreHolderAnimationInterpolator = new FastOutSlowInInterpolator();</span>

	/*
	 * Constructors ================================================================================
	 */

	/**
	 * Creates a new instance of ItemSwipeHelper.
	 */
	public ItemSwipeHelper() {
<span class="fc" id="L212">		this(new Interactor());</span>
<span class="fc" id="L213">	}</span>

	/**
	 * Creates a new instance of ItemSwipeHelper with the specified &lt;var&gt;interactor&lt;/var&gt;.
	 *
	 * @param interactor The interactor that will receive and handle swipe gesture related events.
	 */
	private ItemSwipeHelper(final Interactor interactor) {
<span class="fc" id="L221">		super(interactor);</span>
<span class="fc" id="L222">	}</span>

	/*
	 * Methods =====================================================================================
	 */

	/**
	 * Makes movement flags for the swipe gesture.
	 *
	 * @param movementFlags The desired movement flags. One of flags defined by
	 *                      {@link Movement @Movement} annotation.
	 * @return Swipe flags according to the given movement flags.
	 * @see ItemSwipeHelper.Callback#makeMovementFlags(int, int)
	 */
	public static int makeSwipeFlags(@Movement final int movementFlags) {
<span class="fc" id="L237">		return Interactor.makeMovementFlags(0, movementFlags);</span>
	}

	/**
	 * Sets a duration for animation used to restore position of holder's item view after swipe
	 * gesture for that holder has been canceled.
	 * &lt;p&gt;
	 * Default value: {@link #RESTORE_HOLDER_ANIMATION_DURATION}
	 *
	 * @param duration The desired duration.
	 * @see #getRestoreHolderAnimationDuration()
	 * @see #restoreHolder(RecyclerView.ViewHolder, int, Runnable)
	 * @see OnSwipeListener#onSwipeCanceled(ItemSwipeHelper, RecyclerView.ViewHolder)
	 */
	public void setRestoreHolderAnimationDuration(@IntRange(from = 0) final long duration) {
<span class="fc" id="L252">		this.mRestoreHolderAnimationDuration = Math.max(0L, duration);</span>
<span class="fc" id="L253">	}</span>

	/**
	 * Returns the duration of holder's restore animation.
	 *
	 * @return Duration of restore animation.
	 * @see #setRestoreHolderAnimationDuration(long)
	 */
	public long getRestoreHolderAnimationDuration() {
<span class="fc" id="L262">		return mRestoreHolderAnimationDuration;</span>
	}

	/**
	 * Sets an interpolator for animation used to restore position of holder's item view after swipe
	 * gesture for that holder has been canceled.
	 * &lt;p&gt;
	 * Default value: {@link FastOutSlowInInterpolator}
	 *
	 * @param interpolator The desired interpolator.
	 * @see #getRestoreHolderAnimationInterpolator()
	 * @see OnSwipeListener#onSwipeCanceled(ItemSwipeHelper, RecyclerView.ViewHolder)
	 */
	public void setRestoreHolderAnimationInterpolator(@NonNull final Interpolator interpolator) {
<span class="fc" id="L276">		this.mRestoreHolderAnimationInterpolator = interpolator;</span>
<span class="fc" id="L277">	}</span>

	/**
	 * Returns the interpolator for holder's restore animation.
	 *
	 * @return Animator for restore animation.
	 * @see #setRestoreHolderAnimationInterpolator(Interpolator)
	 */
	@NonNull
	public Interpolator getRestoreHolderAnimationInterpolator() {
<span class="fc" id="L287">		return mRestoreHolderAnimationInterpolator;</span>
	}

	/**
	 * Same as {@link #restoreHolder(RecyclerView.ViewHolder, int, Runnable)} with {@code null}
	 * &lt;var&gt;callback&lt;/var&gt;.
	 */
	public boolean restoreHolder(@NonNull final RecyclerView.ViewHolder viewHolder, @Direction final int direction) {
<span class="fc" id="L295">		return restoreHolder(viewHolder, direction, null);</span>
	}

	/**
	 * Restores position of the given &lt;var&gt;viewHolder&lt;/var&gt; (of its item view) to its initial state.
	 * &lt;p&gt;
	 * When the restore animation finishes, the adapter of the {@link RecyclerViewItemHelper} to which
	 * is this item helper attached, will be notified via {@link RecyclerView.Adapter#notifyItemChanged(int)}
	 * with position of the restored holder.
	 * &lt;p&gt;
	 * This method should be called to restore holder's position whenever swipe gesture for such
	 * holder is canceled to prevent case when holder remains in the swiped state, that is off screen.
	 *
	 * @param viewHolder        The view holder of which position to restore.
	 * @param direction         The direction for which to restore the holder's state.
	 * @param animationCallback Callback to be fired when the restore animation finishes.
	 *                          May be {@code null}.
	 * @return {@code True} restoring of the holder has been performed, {@code false} otherwise.
	 * @see OnSwipeListener#onSwipeCanceled(ItemSwipeHelper, RecyclerView.ViewHolder)
	 */
	public boolean restoreHolder(
			@NonNull final RecyclerView.ViewHolder viewHolder,
			@Direction final int direction,
			@Nullable final Runnable animationCallback
	) {
<span class="fc" id="L320">		final int holderPosition = viewHolder.getAdapterPosition();</span>
<span class="fc bfc" id="L321" title="All 4 branches covered.">		if (viewHolder instanceof SwipeViewHolder &amp;&amp; holderPosition != RecyclerView.NO_POSITION) {</span>
			// Restore holder's swipe view and when restore animation finishes notify the adapter
			// that item at the holder's position has changed so view for the item is again properly
			// drawn by the parent RecyclerView.
<span class="fc" id="L325">			final View swipeView = ((SwipeViewHolder) viewHolder).getInteractiveView(INTERACTION);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">			if (swipeView == null) {</span>
<span class="fc" id="L327">				return false;</span>
			}
<span class="fc" id="L329">			ViewPropertyAnimator animator = null;</span>
<span class="fc bfc" id="L330" title="All 3 branches covered.">			switch (direction) {</span>
				case LEFT:
				case RIGHT:
				case START:
				case END:
<span class="fc bfc" id="L335" title="All 2 branches covered.">					if (swipeView.getTranslationX() != 0) {</span>
<span class="fc" id="L336">						animator = swipeView.animate().translationX(0);</span>
					}
					break;
				case UP:
				case DOWN:
<span class="fc bfc" id="L341" title="All 2 branches covered.">					if (swipeView.getTranslationY() != 0) {</span>
<span class="fc" id="L342">						animator = swipeView.animate().translationY(0);</span>
					}
					break;
				default:
					// Unknown direction specified.
<span class="fc" id="L347">					return false;</span>
			}
<span class="fc" id="L349">			final Runnable notify = new Runnable() {</span>

				/**
				 */
				@Override
				public void run() {
<span class="fc bfc" id="L355" title="All 2 branches covered.">					if (mInteractor.adapter != null) {</span>
<span class="fc" id="L356">						mInteractor.adapter.notifyItemChanged(holderPosition);</span>
					}
<span class="fc bfc" id="L358" title="All 2 branches covered.">					if (animationCallback != null) {</span>
<span class="fc" id="L359">						animationCallback.run();</span>
					}
<span class="fc" id="L361">				}</span>
			};
<span class="fc bfc" id="L363" title="All 2 branches covered.">			if (animator == null) {</span>
<span class="fc" id="L364">				notify.run();</span>
			} else {
<span class="fc" id="L366">				animator.setDuration(mRestoreHolderAnimationDuration).setInterpolator(mRestoreHolderAnimationInterpolator).start();</span>
<span class="fc" id="L367">				swipeView.postDelayed(notify, mRestoreHolderAnimationDuration);</span>
			}
<span class="fc" id="L369">			return true;</span>
		}
<span class="fc" id="L371">		return false;</span>
	}

	/*
	 * Inner classes ===============================================================================
	 */

	/**
	 * A {@link ItemInteractor} implementation used by {@link ItemSwipeHelper} to handle swipe
	 * gesture related callbacks and to delegate swipe events to the view holder that is being swiped.
	 */
	public static final class Interactor extends RecyclerViewItemHelper.ItemInteractor {

		/**
		 * Fraction that the user should move the View to be considered as swiped.
		 *
		 * @see #getSwipeThreshold(RecyclerView.ViewHolder)
		 */
<span class="fc" id="L389">		private float swipeThreshold = SWIPE_THRESHOLD;</span>

		/**
		 * Boolean flag indicating whether swipe should be started whenever a pointer is swiped
		 * over an item view or not.
		 *
		 * @see #setItemViewSwipeEnabled(boolean)
		 */
<span class="fc" id="L397">		private boolean itemSwipeEnabled = true;</span>

		/**
		 * Adapter providing swipeable item views attached to this interactor.
		 *
		 * @see #onAdapterAttached(RecyclerView.Adapter)
		 */
		@VisibleForTesting SwipeAdapter swipeAdapter;

		/**
		 * List containing all registered {@link OnSwipeListener}.
		 *
		 * @see #addOnSwipeListener(OnSwipeListener)
		 * @see #removeOnSwipeListener(OnSwipeListener)
		 */
		private List&lt;OnSwipeListener&gt; listeners;

		/**
		 * Boolean flag indicating whether the swipe gesture is active at this time or not.
		 * If active, the user is swiping one of items in the associated {@link RecyclerView}.
		 *
		 * @see #onSelectedChanged(RecyclerView.ViewHolder, int)
		 * @see #onSwiped(RecyclerView.ViewHolder, int)
		 * @see #clearView(RecyclerView, RecyclerView.ViewHolder)
		 */
		@VisibleForTesting boolean swiping;

		/**
		 * Creates a new instance of swipe gesture Interactor.
		 */
		Interactor() {
<span class="fc" id="L428">			super();</span>
<span class="fc" id="L429">		}</span>

		/**
		 * Sets a boolean flag indicating whether the swipe should be started whenever an active
		 * pointer is swiped over an item view or not.
		 * &lt;p&gt;
		 * If disabled, a swipe for a particular view holder needs to be started via
		 * {@link ItemSwipeHelper#startSwipe(RecyclerView.ViewHolder)} manually.
		 * &lt;p&gt;
		 * Default value: {@code true}
		 *
		 * @param enabled {@code True} to enable automatic swipe, {@code false} to disable it.
		 * @see #isItemViewSwipeEnabled()
		 */
		public void setItemViewSwipeEnabled(boolean enabled) {
<span class="fc" id="L444">			this.itemSwipeEnabled = enabled;</span>
<span class="fc" id="L445">		}</span>

		/**
		 */
		@Override
		public boolean isItemViewSwipeEnabled() {
<span class="fc" id="L451">			return itemSwipeEnabled;</span>
		}

		/**
		 * Sets a fraction that the user should move the holder's {@link View} to be considered as
		 * swiped.
		 * &lt;p&gt;
		 * Default value: {@link #SWIPE_THRESHOLD}
		 *
		 * @param threshold The desired threshold from the range {@code [0.0, 1.0]}.
		 * @see #getSwipeThreshold()
		 * @see ItemSwipeHelper.Callback#getSwipeThreshold(RecyclerView.ViewHolder)
		 */
		public void setSwipeThreshold(@FloatRange(from = 0.0f, to = 1.0f) float threshold) {
<span class="fc" id="L465">			this.swipeThreshold = Math.min(Math.max(threshold, 0.0f), 1.0f);</span>
<span class="fc" id="L466">		}</span>

		/**
		 * Returns the fraction that the user should move the holder's {@link View} to be considered
		 * as swiped.
		 *
		 * @return The swipe threshold from the range {@code [0.0, 1.0]}.
		 * @see #setSwipeThreshold(float)
		 */
		@FloatRange(from = 0.0f, to = 1.0f)
		public float getSwipeThreshold() {
<span class="fc" id="L477">			return swipeThreshold;</span>
		}

		/**
		 */
		@Override
		public float getSwipeThreshold(@NonNull final RecyclerView.ViewHolder viewHolder) {
<span class="fc" id="L484">			return swipeThreshold;</span>
		}

		/**
		 * Registers a callback to be invoked whenever swipe gesture is &lt;b&gt;started&lt;/b&gt;, &lt;b&gt;finished&lt;/b&gt;
		 * or &lt;b&gt;canceled&lt;/b&gt; for a specific {@link RecyclerView.ViewHolder} instance.
		 *
		 * @param listener The desired listener callback to add.
		 * @see #removeOnSwipeListener(OnSwipeListener)
		 */
		public void addOnSwipeListener(@NonNull final OnSwipeListener listener) {
<span class="fc bfc" id="L495" title="All 2 branches covered.">			if (listeners == null) listeners = new ArrayList&lt;&gt;(1);</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">			if (!listeners.contains(listener)) listeners.add(listener);</span>
<span class="fc" id="L497">		}</span>

		/**
		 * Removes the given swipe &lt;var&gt;listener&lt;/var&gt; from the registered listeners.
		 *
		 * @param listener The desired listener to remove.
		 * @see #addOnSwipeListener(OnSwipeListener)
		 */
		public void removeOnSwipeListener(@NonNull final OnSwipeListener listener) {
<span class="fc bfc" id="L506" title="All 2 branches covered.">			if (listeners != null) listeners.remove(listener);</span>
<span class="fc" id="L507">		}</span>

		/**
		 * Notifies all registered {@link OnSwipeListener} that the swipe gesture for the given
		 * &lt;var&gt;viewHolder&lt;/var&gt; has been started.
		 *
		 * @param viewHolder The view holder for which the swipe has started.
		 */
		@VisibleForTesting void notifySwipeStarted(final RecyclerView.ViewHolder viewHolder) {
<span class="fc bfc" id="L516" title="All 4 branches covered.">			if (listeners != null &amp;&amp; !listeners.isEmpty()) {</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">				for (final OnSwipeListener listener : listeners) {</span>
<span class="fc" id="L518">					listener.onSwipeStarted((ItemSwipeHelper) helper, viewHolder);</span>
<span class="fc" id="L519">				}</span>
			}
<span class="fc" id="L521">		}</span>

		/**
		 * Notifies all registered {@link OnSwipeListener} that the swipe gesture for the given
		 * &lt;var&gt;viewHolder&lt;/var&gt; has been finished/completed.
		 *
		 * @param viewHolder The view holder for which the swipe has finished.
		 * @param direction  Direction in which the holder has been swiped.
		 */
		@VisibleForTesting void notifySwipeFinished(final RecyclerView.ViewHolder viewHolder, final int direction) {
<span class="fc bfc" id="L531" title="All 4 branches covered.">			if (listeners != null &amp;&amp; !listeners.isEmpty()) {</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">				for (final OnSwipeListener listener : listeners) {</span>
<span class="fc" id="L533">					listener.onSwipeFinished((ItemSwipeHelper) helper, viewHolder, direction);</span>
<span class="fc" id="L534">				}</span>
			}
<span class="fc" id="L536">		}</span>

		/**
		 * Notifies all registered {@link OnSwipeListener} that the swipe gesture for the given
		 * &lt;var&gt;viewHolder&lt;/var&gt; has been canceled.
		 *
		 * @param viewHolder The view holder for which the swipe has canceled.
		 */
		@VisibleForTesting void notifySwipeCanceled(final RecyclerView.ViewHolder viewHolder) {
<span class="fc bfc" id="L545" title="All 4 branches covered.">			if (listeners != null &amp;&amp; !listeners.isEmpty()) {</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">				for (final OnSwipeListener listener : listeners) {</span>
<span class="fc" id="L547">					listener.onSwipeCanceled((ItemSwipeHelper) helper, viewHolder);</span>
<span class="fc" id="L548">				}</span>
			}
<span class="fc" id="L550">		}</span>

		/**
		 */
		@Override
		protected boolean canAttachAdapter(@NonNull final RecyclerView.Adapter adapter) {
<span class="fc" id="L556">			return adapter instanceof SwipeAdapter;</span>
		}

		/**
		 */
		@Override
		protected void onAdapterAttached(@NonNull final RecyclerView.Adapter adapter) {
<span class="fc" id="L563">			super.onAdapterAttached(adapter);</span>
<span class="fc" id="L564">			this.swipeAdapter = (SwipeAdapter) adapter;</span>
<span class="fc" id="L565">		}</span>

		/**
		 */
		@Override
		protected void onAdapterDetached(@NonNull final RecyclerView.Adapter adapter) {
<span class="fc" id="L571">			super.onAdapterDetached(adapter);</span>
<span class="fc" id="L572">			this.swipeAdapter = null;</span>
<span class="fc" id="L573">			this.resetState();</span>
<span class="fc" id="L574">		}</span>

		/**
		 */
		@Override
		public void setEnabled(boolean enabled) {
<span class="fc" id="L580">			super.setEnabled(enabled);</span>
<span class="fc" id="L581">			this.resetState();</span>
<span class="fc" id="L582">		}</span>

		/**
		 * Resets current state of this interactor to the idle one.
		 */
		private void resetState() {
<span class="fc" id="L588">			this.swiping = false;</span>
<span class="fc" id="L589">		}</span>

		/**
		 */
		@Override
		public boolean isActive() {
<span class="fc" id="L595">			return swiping;</span>
		}

		/**
		 */
		@Override
		public int getMovementFlags(@NonNull final RecyclerView recyclerView, @NonNull final RecyclerView.ViewHolder viewHolder) {
<span class="fc bfc" id="L602" title="All 4 branches covered.">			return shouldHandleInteraction() &amp;&amp; viewHolder instanceof SwipeViewHolder ? swipeAdapter.getItemSwipeFlags(viewHolder.getAdapterPosition()) : 0;</span>
		}

		/**
		 */
		@Override
		public void onSelectedChanged(@Nullable final RecyclerView.ViewHolder viewHolder, final int actionState) {
<span class="fc bfc" id="L609" title="All 4 branches covered.">			if (shouldHandleInteraction() &amp;&amp; viewHolder instanceof SwipeViewHolder) {</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">				switch (actionState) {</span>
					case INTERACTION:
<span class="fc" id="L612">						this.swiping = true;</span>
<span class="fc" id="L613">						final SwipeViewHolder swipeViewHolder = (SwipeViewHolder) viewHolder;</span>
<span class="fc" id="L614">						final View interactiveView = swipeViewHolder.getInteractiveView(INTERACTION);</span>
<span class="fc bfc" id="L615" title="All 2 branches covered.">						if (interactiveView == null) {</span>
<span class="fc" id="L616">							super.onSelectedChanged(viewHolder, actionState);</span>
						} else {
<span class="fc" id="L618">							getDefaultUIUtil().onSelected(interactiveView);</span>
						}
<span class="fc" id="L620">						swipeViewHolder.onSwipeStarted();</span>
<span class="fc" id="L621">						notifySwipeStarted(viewHolder);</span>
<span class="fc" id="L622">						break;</span>
					default:
						// Handle other action states via default behavior.
<span class="fc" id="L625">						super.onSelectedChanged(viewHolder, actionState);</span>
<span class="fc" id="L626">						break;</span>
				}
			} else {
<span class="fc" id="L629">				super.onSelectedChanged(viewHolder, actionState);</span>
			}
<span class="fc" id="L631">		}</span>

		/**
		 */
		@Override
		public boolean onMove(
				@NonNull final RecyclerView recyclerView,
				@NonNull final RecyclerView.ViewHolder viewHolder,
				@NonNull final RecyclerView.ViewHolder target
		) {
			// Ignored for this interactor-callback implementation.
<span class="fc" id="L642">			return false;</span>
		}

		/**
		 */
		@Override
		public void onSwiped(@NonNull final RecyclerView.ViewHolder viewHolder, final int direction) {
<span class="fc bfc" id="L649" title="All 4 branches covered.">			if (shouldHandleInteraction() &amp;&amp; viewHolder instanceof SwipeViewHolder) {</span>
<span class="fc" id="L650">				final SwipeViewHolder swipeViewHolder = (SwipeViewHolder) viewHolder;</span>
<span class="fc" id="L651">				swipeViewHolder.onSwipeFinished(direction);</span>
<span class="fc" id="L652">				notifySwipeFinished(viewHolder, direction);</span>
<span class="fc" id="L653">				this.resetState();</span>
			}
<span class="fc" id="L655">		}</span>

		/**
		 */
		@Override
		public void clearView(@NonNull final RecyclerView recyclerView, @NonNull final RecyclerView.ViewHolder viewHolder) {
<span class="fc bfc" id="L661" title="All 4 branches covered.">			if (shouldHandleInteraction() &amp;&amp; viewHolder instanceof SwipeViewHolder) {</span>
<span class="fc" id="L662">				final SwipeViewHolder swipeViewHolder = (SwipeViewHolder) viewHolder;</span>
<span class="fc" id="L663">				final View interactiveView = swipeViewHolder.getInteractiveView(INTERACTION);</span>
<span class="fc bfc" id="L664" title="All 2 branches covered.">				if (interactiveView == null) {</span>
<span class="fc" id="L665">					super.clearView(recyclerView, viewHolder);</span>
				} else {
<span class="fc" id="L667">					getDefaultUIUtil().clearView(interactiveView);</span>
				}
<span class="fc" id="L669">				final int adapterPosition = viewHolder.getAdapterPosition();</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">				if (adapterPosition != RecyclerView.NO_POSITION) {</span>
<span class="fc" id="L671">					swipeViewHolder.onSwipeCanceled();</span>
<span class="fc" id="L672">					notifySwipeCanceled(viewHolder);</span>
				}
<span class="fc" id="L674">				this.resetState();</span>
<span class="fc" id="L675">			} else {</span>
<span class="fc" id="L676">				super.clearView(recyclerView, viewHolder);</span>
			}
<span class="fc" id="L678">		}</span>
	}

	/**
	 * A {@link DefaultItemAnimator} extension which overrides default implementation of
	 * {@link #animateChange(RecyclerView.ViewHolder, RecyclerView.ViewHolder, int, int, int, int)}
	 * in a way that does not cause any drawing artifacts to occur when state of item view for swiped
	 * view holder is about to be restored via {@link #restoreHolder(RecyclerView.ViewHolder, int, Runnable)}.
	 * &lt;p&gt;
	 * This animator should be used for {@link RecyclerView} to which is {@link ItemSwipeHelper} attached.
	 *
	 * @author Martin Albedinsky
	 */
<span class="fc" id="L691">	public static class SwipeItemAnimator extends DefaultItemAnimator {</span>

		/**
		 */
		@Override
		public boolean animateChange(
				@NonNull final RecyclerView.ViewHolder oldHolder,
				@NonNull final RecyclerView.ViewHolder newHolder,
				final int fromX,
				final int fromY,
				final int toX,
				final int toY
		) {
<span class="fc bfc" id="L704" title="All 4 branches covered.">			if (fromX == toX &amp;&amp; fromY == toY) {</span>
<span class="fc bfc" id="L705" title="All 2 branches covered.">				if (newHolder.equals(oldHolder)) {</span>
<span class="fc" id="L706">					dispatchChangeFinished(newHolder, false);</span>
				} else {
<span class="fc" id="L708">					dispatchChangeFinished(oldHolder, true);</span>
<span class="fc" id="L709">					dispatchChangeFinished(newHolder, false);</span>
				}
<span class="fc" id="L711">				return false;</span>
			}
<span class="fc" id="L713">			return super.animateChange(oldHolder, newHolder, fromX, fromY, toX, toY);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span>Generated by the Android Gradle plugin 2.3.1</div></body></html>